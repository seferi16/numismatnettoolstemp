<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Back Cam QR + Zoom (Big)</title>
  <script src="https://unpkg.com/html5-qrcode"></script>
  <style>
    :root { --pad: 14px; }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 16px; background: #0f172a; color: #e5e7eb;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display: flex; flex-direction: column; gap: 12px; align-items: center;
    }
    h1 { margin: 0 0 8px; font-size: 18px; font-weight: 600; color: #fff; }
    .controls {
      display: flex; gap: 10px; align-items: center; flex-wrap: wrap; width: 100%;
      max-width: 1100px; justify-content: center;
    }
    .btn {
      padding: 10px 16px; border: 0; border-radius: 8px; cursor: pointer; color: #fff;
      background: #2563eb; font-size: 15px; font-weight: 600;
    }
    .btn.secondary { background: #475569; }
    .slider-wrap {
      display: flex; align-items: center; gap: 10px; color: #cbd5e1; font-size: 14px;
      background: #0b1220; padding: 8px 12px; border-radius: 10px;
    }
    input[type="range"] { width: 220px; }
    .stage {
      width: min(1100px, 96vw);
      height: min(75vh, 720px);
      border: 2px solid #334155; border-radius: 12px; overflow: hidden;
      background: #000; display: flex; align-items: stretch; justify-content: stretch;
    }
    /* Make the internal video/canvas fill big */
    #reader { width: 100%; height: 100%; }
  </style>
</head>
<body>
  <h1>Back Camera QR Scanner</h1>

  <div class="controls">
    <button id="startBtn" class="btn">Start (Back Cam)</button>
    <button id="stopBtn" class="btn secondary" disabled>Stop</button>

    <div class="slider-wrap">
      <span>Zoom</span>
      <input id="zoomSlider" type="range" min="1" max="1" step="0.1" value="1" disabled>
      <span id="zoomVal">1.0×</span>
    </div>
  </div>

  <div class="stage">
    <div id="reader"></div>
  </div>

  <script>
    // ===== Basic config =====
    const SCAN_FPS = 12;
    const ASPECT = 1.7778; // 16:9
    const DEFAULT_ZOOM = 3.5; // will be clamped to device max
    // ========================

    let html5QrCode = null;
    let runningTrack = null;
    let capsCache = null;
    const startBtn = document.getElementById("startBtn");
    const stopBtn  = document.getElementById("stopBtn");
    const zoomSlider = document.getElementById("zoomSlider");
    const zoomVal = document.getElementById("zoomVal");

    function looksLikeBack(label, facing) {
      if (String(facing || "").toLowerCase() === "environment") return true;
      return /tele|macro|environment|back|rear/i.test(label || "");
    }

    function resolveVideoTrack() {
      if (html5QrCode && typeof html5QrCode.getRunningTrack === "function") {
        const t = html5QrCode.getRunningTrack();
        if (t) return t;
      }
      const video = document.querySelector("#reader video");
      if (video && video.srcObject) {
        const tracks = video.srcObject.getVideoTracks();
        if (tracks && tracks.length) return tracks[0];
      }
      return null;
    }

    async function ensurePermission() {
      try {
        const s = await navigator.mediaDevices.getUserMedia({ video: true });
        s.getTracks().forEach(t => t.stop());
      } catch (e) {
        alert("Kamera izni gerekli.");
        throw e;
      }
    }

    async function startHtml5Qrcode(constraint) {
      if (!html5QrCode) html5QrCode = new Html5Qrcode("reader");
      await html5QrCode.start(
        constraint,
        {
          fps: SCAN_FPS,
          aspectRatio: ASPECT,
          // no qrbox -> full frame decode for simplicity; big preview
          videoConstraints: { width: { ideal: 1920 }, height: { ideal: 1080 } }
        },
        onScanSuccess,
        onScanError
      );
      await new Promise(r => setTimeout(r, 120));
      runningTrack = resolveVideoTrack();
      capsCache = runningTrack && runningTrack.getCapabilities ? runningTrack.getCapabilities() : null;
      setupZoomUI();
    }

    async function startBackCamera() {
      startBtn.disabled = true;
      try {
        await ensurePermission();

        // 1) Try pure facingMode: environment
        try {
          await startHtml5Qrcode({ facingMode: { exact: "environment" } });
          const facing = runningTrack?.getSettings?.().facingMode;
          if (looksLikeBack("", facing)) {
            stopBtn.disabled = false;
            return;
          }
          // If driver lied, fall through to iteration
          await stopScanner();
        } catch (_) {
          // continue to iteration
        }

        // 2) Iterate deviceIds to find a back-ish camera
        const cams = await Html5Qrcode.getCameras();
        // Back-labeled first
        const ordered = [...cams].sort((a, b) => {
          const A = looksLikeBack(a.label), B = looksLikeBack(b.label);
          return (A === B) ? 0 : (A ? -1 : 1);
        });

        for (const cam of ordered) {
          try {
            await startHtml5Qrcode({ deviceId: { exact: cam.id } });
            const facing = runningTrack?.getSettings?.().facingMode;
            if (looksLikeBack(cam.label, facing)) {
              stopBtn.disabled = false;
              return; // success
            } else {
              await stopScanner();
            }
          } catch (_) {
            // try next
          }
        }

        // 3) Last resort: non-exact environment (some browsers accept this)
        try {
          await startHtml5Qrcode({ facingMode: "environment" });
          stopBtn.disabled = false;
          return;
        } catch (e) {
          throw e;
        }

      } catch (err) {
        console.error(err);
        alert("Arka kamerayı başlatamadık (izin/cihaz kısıtı).");
        startBtn.disabled = false;
      }
    }

    function setupZoomUI() {
      if (capsCache && capsCache.zoom) {
        zoomSlider.disabled = false;
        zoomSlider.min = capsCache.zoom.min ?? 1;
        zoomSlider.max = capsCache.zoom.max ?? 4;
        zoomSlider.step = capsCache.zoom.step ?? 0.1;

        const init = Math.max(Number(zoomSlider.min),
                      Math.min(Number(zoomSlider.max), DEFAULT_ZOOM));
        zoomSlider.value = init;
        zoomVal.textContent = `${init.toFixed(1)}×`;
        // apply initial zoom
        runningTrack.applyConstraints({ advanced: [{ zoom: init }] }).catch(() => {});
      } else {
        zoomSlider.disabled = true;
        zoomSlider.value = 1;
        zoomVal.textContent = "1.0×";
      }
    }

    async function stopScanner() {
      try {
        if (html5QrCode && html5QrCode.isScanning) {
          await html5QrCode.stop();
        }
      } catch {}
      runningTrack = null;
      capsCache = null;
      stopBtn.disabled = true;
      startBtn.disabled = false;
      zoomSlider.disabled = true;
      zoomSlider.value = 1;
      zoomVal.textContent = "1.0×";
    }

    function onScanSuccess(text) {
      console.log("QR:", text);
      // If you want to stop after one scan, uncomment:
      // stopScanner();
    }
    function onScanError(_) { /* ignore decode noise */ }

    // UI events
    startBtn.addEventListener("click", startBackCamera);
    stopBtn.addEventListener("click", stopScanner);
    zoomSlider.addEventListener("input", async (e) => {
      const z = Number(e.target.value);
      zoomVal.textContent = `${z.toFixed(1)}×`;
      try {
        if (runningTrack && runningTrack.applyConstraints) {
          await runningTrack.applyConstraints({ advanced: [{ zoom: z }] });
        }
      } catch {}
    });
  </script>
</body>
</html>
