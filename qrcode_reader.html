<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Numismat.net Ürün Tarayıcı</title>
  <script src="https://unpkg.com/html5-qrcode"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  <style>
    :root { --pad: 14px; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#f4f6f8; color:#111; margin:0; padding:20px; display:flex; flex-direction:column; align-items:center; gap:16px; }
    h1 { font-size:22px; margin:6px 0 4px; }
    .wrap { width: min(1000px, 96vw); display:grid; grid-template-columns: 360px 1fr; gap:16px; }
    @media (max-width: 820px) {.wrap{grid-template-columns:1fr}}
    .card { background:#fff; border:1px solid #e5e7eb; border-radius:10px; box-shadow: 0 3px 10px rgba(0,0,0,.06); }
    .card > .hd { padding:10px var(--pad); font-weight:600; border-bottom:1px solid #eef1f4; }
    .card > .bd { padding: var(--pad); }
    #info img { width:100%; border-radius:6px; object-fit:cover; max-height:220px; }
    table { width:100%; border-collapse: collapse; margin-top:8px; } th, td { padding:8px; text-align:left; }
    th { width:120px; color:#333; background:#f1f5f9 } tr:nth-child(even) td { background:#fafafa; } tr:hover td { background:#e8f4ff; }
    .btn { padding:10px 14px; font-size:15px; border:none; border-radius:6px; cursor:pointer; color:#fff; background:#2563eb; }
    .btn:hover { filter:brightness(.95); } .btn.sold { background:#16a34a; } .btn.secondary { background:#6b7280; } .btn.light { background:#111827; }
    .btn-row { display:flex; gap:8px; flex-wrap:wrap; margin-top:10px; }
    .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    .controls label { font-size:14px; color:#374151; display:flex; align-items:center; gap:6px; }
    .controls select, .controls input[type="range"] { padding:8px; border:1px solid #d1d5db; border-radius:6px; background:#fff; }
    #reader__scan_region { width:100%; min-height:380px; }
    #videoWrap { position:relative; }
    #videoWrap::after { content:""; position:absolute; inset:0; pointer-events:none; border:2px solid rgba(255,255,255,.6); border-radius:10px; margin: 20px; }
    .hint { font-size:12px; color:#6b7280; margin-top:6px; }
    pre.debug { background:#0b1220; color:#d1e7ff; padding:10px; border-radius:8px; overflow:auto; max-height:240px; font-size:12px; }
    .warn { color:#b45309; font-weight:600; }
    .ok { color:#059669; font-weight:600; }
    .disabled { opacity:.5; pointer-events:none; }
  </style>
</head>
<body>
  <h1>Numismat.net Ürün Tarayıcı</h1>

  <div class="wrap">
    <!-- Product info -->
    <div id="info" class="card">
      <div class="hd">Ürün Bilgisi</div>
      <div class="bd">
        <img id="product-image" src="placeholder.jpg" alt="Ürün Görseli">
        <table>
          <tr><th>Başlık</th><td id="name-tr">[Henüz taranmadı.]</td></tr>
          <tr><th>Fiyat</th><td id="price">[Henüz taranmadı.]</td></tr>
          <tr><th>Stok Kodu</th><td id="model">[Henüz taranmadı.]</td></tr>
        </table>
        <div class="btn-row">
          <button id="product-link" class="btn" onclick="goToProduct()" style="display:none;">Ürüne Git</button>
          <button id="sold-button" class="btn sold" onclick="markAsSold()" style="display:none;">Ürün Satıldı</button>
          <button id="rescan-button" class="btn secondary" onclick="rescan()">Yeniden Tara</button>
        </div>
      </div>
    </div>

    <!-- Scanner -->
    <div class="card">
      <div class="hd">Kamera Tarayıcı</div>
      <div class="bd">
        <div class="controls">
          <label for="cameraSelect">Kamera:</label>
          <select id="cameraSelect"></select>

          <button class="btn light" id="startBtn">Başlat</button>
          <button class="btn secondary" id="stopBtn" disabled>Dur</button>

          <!-- Always visible; disabled if unsupported -->
          <label id="zoomLabel">Yakınlaştırma:
            <input id="zoomSlider" type="range" min="1" max="1" step="0.1" value="1" disabled>
            <span id="zoomVal">1.0x</span>
          </label>

          <button class="btn" id="torchBtn" style="display:none;">Flaş Aç</button>
          <button class="btn" id="focusBtn">Ortaya Odakla</button>
        </div>

        <div id="videoWrap" style="margin-top:12px;">
          <div id="reader__scan_region"></div>
        </div>
        <div class="hint">
          HTTPS üzerinde açın. Android Chrome çoğu cihazda zoom/torch destekler; iOS Safari genelde kısıtlıdır.
        </div>

        <h3 style="margin-top:14px;">Debug</h3>
        <pre class="debug" id="debugBox">Hazır…</pre>
      </div>
    </div>
  </div>

  <script>
  // ===== CONFIG =====
  const TELEGRAM_BACKEND_ENDPOINT = "";
  const SCAN_FPS = 12;
  const QRBOX_SIZE = 360;         // a bit larger so the code fills the box
  const DEFAULT_ZOOM = 3.5;       // start close to your max (4)
  const REQUESTED_WIDTH = 1920;   // ask for higher resolution
  const REQUESTED_HEIGHT = 1080;  // (browser may give closest match)
  // ===================

  let html5QrCode = null;
  let runningCameraId = null;
  let runningTrack = null;
  let capsCache = null;
  let torchOn = false;

  const el = (id) => document.getElementById(id);
  const cameraSelect = el("cameraSelect");
  const startBtn = el("startBtn");
  const stopBtn = el("stopBtn");
  const zoomSlider = el("zoomSlider");
  const zoomVal = el("zoomVal");
  const torchBtn = el("torchBtn");  // will stay hidden if unsupported
  const focusBtn = el("focusBtn");  // will be a soft “nudge” only
  const debugBox = document.getElementById("debugBox");

  function logDebug(msg) {
    const t = new Date().toLocaleTimeString();
    debugBox && (debugBox.textContent += `\n[${t}] ${typeof msg === 'string' ? msg : JSON.stringify(msg, null, 2)}`);
    debugBox && (debugBox.scrollTop = debugBox.scrollHeight);
  }

  async function listCameras() {
    const cams = await Html5Qrcode.getCameras();
    cameraSelect.innerHTML = "";
    cams.forEach((c, i) => {
      const opt = document.createElement("option");
      opt.value = c.id;
      opt.textContent = c.label || `Kamera ${i+1}`;
      cameraSelect.appendChild(opt);
    });
    // prefer back/telephoto/macro if label hints exist
    let preferred =
      cams.find(c => /tele|macro/i.test(c.label)) ||
      cams.find(c => /back|rear|environment/i.test(c.label)) ||
      cams[cams.length - 1] || cams[0];
    if (preferred) cameraSelect.value = preferred.id;
    logDebug({ cameras: cams });
  }

  function resolveVideoTrack() {
    if (html5QrCode && typeof html5QrCode.getRunningTrack === "function") {
      const tr = html5QrCode.getRunningTrack();
      if (tr) return tr;
    }
    const video = document.querySelector("#reader__scan_region video");
    if (video && video.srcObject) {
      const tracks = video.srcObject.getVideoTracks();
      if (tracks && tracks.length) return tracks[0];
    }
    return null;
  }

  async function startScanner() {
    try {
      if (!html5QrCode) html5QrCode = new Html5Qrcode("reader__scan_region");
      runningCameraId = cameraSelect.value;

      await html5QrCode.start(
        { deviceId: { exact: runningCameraId } },
        {
          fps: SCAN_FPS,
          qrbox: QRBOX_SIZE,
          aspectRatio: 1.7778,
          // ask browser for higher resolution; it may give nearest it can
          videoConstraints: {
            width: { ideal: REQUESTED_WIDTH },
            height: { ideal: REQUESTED_HEIGHT }
          }
        },
        onScanSuccess,
        onScanError
      );

      await new Promise(r => setTimeout(r, 150));
      runningTrack = resolveVideoTrack();
      if (!runningTrack) { logDebug("⚠️ video track yok"); return; }

      const caps = runningTrack.getCapabilities ? runningTrack.getCapabilities() : null;
      capsCache = caps;
      logDebug({ capabilities: caps });

      // Zoom: your device supports up to ~4 — enable slider & default high
      if (caps && caps.zoom) {
        zoomSlider.disabled = false;
        zoomSlider.min = caps.zoom.min ?? 1;
        zoomSlider.max = caps.zoom.max ?? 4;     // your debug said 4
        zoomSlider.step = caps.zoom.step ?? 0.1;
        const initZoom = Math.max(zoomSlider.min, Math.min(zoomSlider.max, DEFAULT_ZOOM));
        zoomSlider.value = initZoom;
        zoomVal.textContent = `${Number(zoomSlider.value).toFixed(1)}x`;
        try {
          await applyConstraints({ advanced: [{ zoom: Number(zoomSlider.value) }] });
          logDebug(`zoom=${zoomSlider.value}`);
        } catch (e) { logDebug(`zoom apply fail: ${e}`); }
      } else {
        zoomSlider.disabled = true;
      }

      // no torch/focus on your device — buttons will do nothing if unsupported
      if (!(caps && caps.torch)) torchBtn.style.display = "none";

      // enable pinch-to-zoom mapped to the slider
      enablePinchToZoom();

      startBtn.disabled = true;
      stopBtn.disabled = false;
    } catch (err) {
      logDebug(`start error: ${err.message || err}`);
      alert("Kamera başlatılamadı. HTTPS ve izinleri kontrol edin.");
    }
  }

  async function stopScanner() {
    try {
      if (html5QrCode && html5QrCode.isScanning) await html5QrCode.stop();
    } catch (e) { logDebug(`stop error: ${e}`); }
    runningTrack = null; capsCache = null; startBtn.disabled = false; stopBtn.disabled = true;
  }

  function onScanSuccess(qrText) {
    logDebug({ scanned: qrText });
    stopScanner();
    fetchProductData(qrText);
  }
  function onScanError(_) {}

  async function applyConstraints(constraints) {
    if (runningTrack && runningTrack.applyConstraints) {
      await runningTrack.applyConstraints(constraints);
    } else {
      throw new Error("applyConstraints yok");
    }
  }

  // pinch gestures -> zoom slider
  function enablePinchToZoom() {
    const container = document.getElementById("videoWrap");
    let startDist = null;
    let startZoom = null;

    container.addEventListener("touchstart", (e) => {
      if (e.touches.length === 2) {
        startDist = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY
        );
        startZoom = Number(zoomSlider.value);
      }
    }, { passive: true });

    container.addEventListener("touchmove", async (e) => {
      if (e.touches.length === 2 && startDist && startZoom != null && !zoomSlider.disabled) {
        const dist = Math.hypot(
          e.touches[0].pageX - e.touches[1].pageX,
          e.touches[0].pageY - e.touches[1].pageY
        );
        const delta = (dist - startDist) / 200; // sensitivity
        let newZoom = Math.max(Number(zoomSlider.min), Math.min(Number(zoomSlider.max), startZoom + delta));
        if (Math.abs(newZoom - Number(zoomSlider.value)) >= 0.05) {
          zoomSlider.value = newZoom;
          zoomVal.textContent = `${newZoom.toFixed(1)}x`;
          try { await applyConstraints({ advanced: [{ zoom: newZoom }] }); } catch {}
        }
      }
    }, { passive: true });

    container.addEventListener("touchend", () => {
      startDist = null; startZoom = null;
    });
  }

  // UI events
  document.getElementById("startBtn").addEventListener("click", startScanner);
  document.getElementById("stopBtn").addEventListener("click", stopScanner);
  document.getElementById("zoomSlider").addEventListener("input", async (e) => {
    const z = Number(e.target.value);
    zoomVal.textContent = `${z.toFixed(1)}x`;
    try { await applyConstraints({ advanced: [{ zoom: z }] }); } catch (err) { logDebug(`zoom change fail: ${err}`); }
  });
  document.getElementById("torchBtn").addEventListener("click", async () => {
    // most likely hidden for you; kept for devices that do support it
    if (!(capsCache && capsCache.torch)) return;
    try {
      torchOn = !torchOn;
      await applyConstraints({ advanced: [{ torch: torchOn }] });
      document.getElementById("torchBtn").textContent = torchOn ? "Flaş Kapat" : "Flaş Aç";
    } catch {}
  });
  document.getElementById("focusBtn").addEventListener("click", async () => {
    // your device reports no focus controls; this is a soft nudge only
    if (capsCache && capsCache.focusMode && capsCache.focusMode.includes("continuous")) {
      try { await applyConstraints({ advanced: [{ focusMode: "continuous" }] }); } catch {}
    }
    // else: nothing more we can do from web if no capability is exposed
    logDebug("Focus: cihaz web odak kontrolü sunmuyor.");
  });

  // products / telegram (same as before)
  function fetchProductData(qrLink) {
    Papa.parse("products.csv", {
      download: true, header: true,
      complete: function(results) {
        const rows = results.data || [];
        const norm = (s) => (s || "").trim();
        const product = rows.find(row => norm(row.link) === norm(qrLink));
        if (product) {
          document.getElementById("name-tr").innerText = product.name_tr || "-";
          const price = Number(product.price);
          const taxed = isFinite(price) ? (price * 1.20).toFixed(2) : "-";
          document.getElementById("price").innerText = taxed === "-" ? "-" : `₺${taxed}`;
          document.getElementById("model").innerText = product.model || "-";
          document.getElementById("product-image").src = product.image || "placeholder.jpg";
          document.getElementById("product-link").style.display = "inline-block";
          document.getElementById("sold-button").style.display = "inline-block";
          document.getElementById("product-link").setAttribute("data-link", product.link || "");
        } else {
          resetInfo(); alert("Ürün bulunamadı.");
        }
      },
      error: function(err) { alert("products.csv yüklenemedi."); }
    });
  }
  function resetInfo() {
    document.getElementById("name-tr").innerText = "[Henüz taranmadı.]";
    document.getElementById("price").innerText = "[Henüz taranmadı.]";
    document.getElementById("model").innerText = "[Henüz taranmadı.]";
    document.getElementById("product-image").src = "placeholder.jpg";
    document.getElementById("product-link").style.display = "none";
    document.getElementById("sold-button").style.display = "none";
  }
  function goToProduct(){ const link = document.getElementById("product-link").getAttribute("data-link"); if (link) location.href = link; }
  async function markAsSold(){
    if (!TELEGRAM_BACKEND_ENDPOINT) return alert("Telegram gönderimi devre dışı.");
    const msg = `Başlık: ${document.getElementById("name-tr").innerText}\nFiyat: ${document.getElementById("price").innerText}\nStok Kodu: ${document.getElementById("model").innerText}\nÜrün Satıldı!\n`;
    try {
      const res = await fetch(TELEGRAM_BACKEND_ENDPOINT, { method:"POST", headers:{ "Content-Type":"application/json" }, body: JSON.stringify({ text: msg })});
      alert(res.ok ? "Telegram mesajı gönderildi." : "Telegram mesajı gönderilemedi.");
    } catch { alert("Telegram servisine bağlanırken hata oluştu."); }
  }
  async function rescan(){ resetInfo(); await stopScanner(); await startScanner(); }

  // init
  (async () => {
    try { await listCameras(); logDebug("Hazır. Başlat'a basın."); }
    catch (e){ logDebug(`camera list err: ${e}`); alert("Kameralar listelenemedi."); }
  })();

  // expose for inline
  window.goToProduct = goToProduct;
  window.markAsSold = markAsSold;
  window.rescan = rescan;
</script>

</body>
</html>

